import numpy as np
import torch
import cv2
from .promoters import get_prompts_from_mask


class SegmentationFixer:
    def __init__(self, sam_predictor):
        """
        Initialize with a SamPredictor instance.
        """
        self.predictor = sam_predictor
        self.current_image = None

    def set_image(self, image):
        """
        Set the image for the predictor.
        Image should be RGB uint8.
        """
        self.current_image = image
        self.predictor.set_image(image)

    def fix_segmentation(
        self, existing_mask, prompt_type="center", reject_threshold=0.95
    ):
        """
        Run SAM using prompts derived from the existing_mask.

        Args:
            existing_mask: Binary mask (H, W) or boolean mask.
            prompt_type: 'box', 'center', 'points'
            reject_threshold: If IoU between new and old is > this, maybe we just keep old?
                              Or maybe this logic belongs outside.

        Returns:
            best_mask: The mask generated by SAM.
            scores: Scores returned by SAM.
            logits: Logits returned by SAM.
        """
        if self.current_image is None:
            raise RuntimeError("Image not set. Call set_image() first.")

        # Ensure mask is binary uint8 or bool
        if existing_mask.dtype != bool:
            existing_mask = existing_mask > 0

        prompts = get_prompts_from_mask(existing_mask, prompt_type)

        if prompts is None:
            # Could happen if mask is empty
            return None, 0.0, None

        masks, scores, logits = None, None, None

        if prompt_type == "box":
            box = prompts
            masks, scores, logits = self.predictor.predict(
                box=box,
                multimask_output=True,  # Usually we want to see multiple options or just the best? SAM default is 3 masks.
            )
        elif prompt_type in ["center", "points"]:
            points, labels = prompts
            masks, scores, logits = self.predictor.predict(
                point_coords=points, point_labels=labels, multimask_output=True
            )

        # Select best mask based on SAM's score
        best_idx = np.argmax(scores)
        best_mask = masks[best_idx]
        best_score = scores[best_idx]

        return best_mask, best_score, logits

    def batch_fix(self, images, masks, prompt_type="box"):
        """
        Generator for fixing a batch of images and masks.
        """
        for img, mask in zip(images, masks):
            self.set_image(img)
            yield self.fix_segmentation(mask, prompt_type)

    def calculate_iou(self, mask1, mask2):
        intersection = np.logical_and(mask1, mask2).sum()
        union = np.logical_or(mask1, mask2).sum()
        if union == 0:
            return 0.0
        return intersection / union
